<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Catch the Star - Neon Space Edition - Kuzo</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: #0b1221;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    height: 100%;
    color: #7be495;
  }
  #gameCanvas {
    display: block;
    margin: 0 auto;
    background: transparent;
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 1;
  }
  #hud {
    position: fixed;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 25px;
    font-size: 22px;
    font-weight: 700;
    text-shadow: 0 0 6px #7be495cc;
    z-index: 20;
    user-select: none;
  }
  #muteBtn {
    position: fixed;
    top: 12px;
    right: 20px;
    background: #192934;
    border: none;
    color: #7be495;
    font-weight: bold;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    text-shadow: 0 0 8px #7be495cc;
    z-index: 20;
    user-select: none;
    transition: background 0.3s;
  }
  #muteBtn:hover {
    background: #4caf50;
  }
  #bottomCreditRight {
    position: fixed;
    bottom: 8px;
    right: 12px;
    font-size: 14px;
    font-weight: 600;
    color: #7be495cc;
    user-select: none;
    z-index: 20;
    text-shadow: 0 0 8px #7be495cc;
  }
  #bottomCreditLeft {
    position: fixed;
    bottom: 8px;
    left: 12px;
    font-size: 14px;
    font-weight: 600;
    color: #7be495cc;
    user-select: none;
    z-index: 20;
    text-shadow: 0 0 8px #7be495cc;
  }
  #startOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(11, 18, 33, 0.9);
    color: #7be495;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 26px;
    font-weight: 700;
    user-select: none;
    z-index: 30;
  }
  #startBtn {
    margin-top: 20px;
    font-size: 22px;
    background: linear-gradient(45deg, #7be495, #4caf50);
    border: none;
    padding: 15px 40px;
    border-radius: 10px;
    color: #0b1221;
    cursor: pointer;
    box-shadow: 0 0 15px #4caf50aa;
    font-weight: 800;
    user-select: none;
    transition: background 0.3s;
  }
  #startBtn:hover {
    background: linear-gradient(45deg, #4caf50, #7be495);
  }
  #gameOverOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(11, 18, 33, 0.95);
    color: #7be495;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 28px;
    font-weight: 700;
    user-select: none;
    z-index: 35;
  }
  #restartBtn {
    margin-top: 25px;
    font-size: 24px;
    background: linear-gradient(45deg, #7be495, #4caf50);
    border: none;
    padding: 14px 44px;
    border-radius: 10px;
    color: #0b1221;
    cursor: pointer;
    box-shadow: 0 0 18px #4caf50cc;
    font-weight: 800;
    user-select: none;
    transition: background 0.3s;
  }
  #restartBtn:hover {
    background: linear-gradient(45deg, #4caf50, #7be495);
  }
  #leaderboard {
    position: fixed;
    top: 60px;
    right: 20px;
    width: 200px;
    background: rgba(11, 18, 33, 0.85);
    border-radius: 10px;
    padding: 10px 15px;
    color: #7be495cc;
    font-weight: 700;
    font-size: 16px;
    z-index: 25;
    user-select: none;
  }
  #leaderboard h3 {
    margin: 0 0 10px 0;
    color: #7be495;
    text-align: center;
  }
  #leaderboard ul {
    list-style: none;
    padding-left: 10px;
    margin: 0;
  }
  #leaderboard li {
    padding: 3px 0;
    border-bottom: 1px solid #7be49533;
  }
  #joystickBase {
    position: fixed;
    bottom: 50px;
    left: 50px;
    width: 100px;
    height: 100px;
    background: #192934cc;
    border-radius: 50%;
    display: none;
    touch-action: none;
    z-index: 40;
  }
  #joystickStick {
    position: absolute;
    top: 40px;
    left: 40px;
    width: 20px;
    height: 20px;
    background: #4caf50cc;
    border-radius: 50%;
    transform: translate(0, 0);
    transition: transform 0.1s;
  }
  #controlModeSelect {
    margin-top: 15px;
    font-size: 18px;
    padding: 6px 12px;
    border-radius: 8px;
    border: none;
    background: #0b1221cc;
    color: #7be495;
    cursor: pointer;
    user-select: none;
  }
  #playerNameInput {
    margin-top: 15px;
    padding: 8px 12px;
    border-radius: 8px;
    border: none;
    width: 200px;
    font-size: 18px;
    color: #7be495;
    background: #0b1221cc;
    text-align: center;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  <div id="score">Score: 0</div>
  <div id="time">Time: 30</div>
  <div id="level">Level: 1</div>
</div>

<button id="muteBtn" title="Toggle Mute">ðŸ”Š</button>

<div id="bottomCreditRight">by Anar &amp; Ermuun</div>
<div id="bottomCreditLeft">Credits to Tselmeg</div>

<div id="startOverlay">
  Catch the Star<br>
  <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="15" />
  <select id="controlModeSelect" title="Select Control Mode">
    <option value="pc" selected>PC (Keyboard)</option>
    <option value="mobile">Mobile (Joystick)</option>
  </select>
  <button id="startBtn">Start Game</button>
  <div id="leaderboard">
    <h3>Leaderboard</h3>
    <ul id="leaderboardList"></ul>
  </div>
</div>

<div id="gameOverOverlay">
  Game Over!<br>
  <div id="finalScore" style="margin-top:12px;"></div>
  <button id="restartBtn">Restart</button>
</div>

<div id="joystickBase">
  <div id="joystickStick"></div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreDisplay = document.getElementById('score');
  const timeDisplay = document.getElementById('time');
  const levelDisplay = document.getElementById('level');
  const muteBtn = document.getElementById('muteBtn');
  const startOverlay = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreDisplay = document.getElementById('finalScore');
  const restartBtn = document.getElementById('restartBtn');
  const playerNameInput = document.getElementById('playerNameInput');
  const controlModeSelect = document.getElementById('controlModeSelect');
  const leaderboardList = document.getElementById('leaderboardList');
  const joystickBase = document.getElementById('joystickBase');
  const joystickStick = document.getElementById('joystickStick');

  let audioContext = null;
  let bgMusic = null;
  let isMuted = false;

  function setupAudio() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      bgMusic = new Audio("https://cdn.jsdelivr.net/gh/jshawl/catch-the-star-assets/spacey-arcade-loop.mp3");
      bgMusic.loop = true;
      bgMusic.volume = 0.3;
      bgMusic.play();
    }
  }

  muteBtn.onclick = () => {
    if (!bgMusic) return;
    isMuted = !isMuted;
    bgMusic.muted = isMuted;
    muteBtn.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
  };

  const colors = {
    gold: "#ffdd57",
    blue: "#57ddff",
    red: "#ff5757",
    player: "#7be495",
    obstacle: "#ff4444"
  };

  const player = {
    size: 28,
    x: 0,
    y: 0,
    speed: 5,
    vx: 0,
    vy: 0,
    trail: []
  };

  let keys = {};
  let stars = [];
  let obstacles = [];
  let particles = [];

  const bgStarsLayers = [
    { count: 100, speed: 0.2, size: 1, stars: [] },
    { count: 60, speed: 0.4, size: 1.5, stars: [] },
    { count: 40, speed: 0.7, size: 2, stars: [] }
  ];

  let score = 0;
  let timeLeft = 30;
  let level = 1;
  let gameStarted = false;

  // Utility funcs
  function randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }
  function clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
  }
  function distance(x1,y1,x2,y2) {
    return Math.hypot(x2 - x1, y2 - y1);
  }
  function rectIntersect(x1,y1,w1,h1, x2,y2,w2,h2) {
    return !(x2 > x1 + w1 || 
             x2 + w2 < x1 || 
             y2 > y1 + h1 ||
             y2 + h2 < y1);
  }

  // Player reset
  function resetPlayer() {
    player.x = canvas.width / 2 - player.size / 2;
    player.y = canvas.height / 2 - player.size / 2;
    player.vx = 0;
    player.vy = 0;
    player.trail = [];
  }

  // Init BG stars
  function initBgStars() {
    bgStarsLayers.forEach(layer => {
      layer.stars = [];
      for(let i=0; i<layer.count; i++) {
        layer.stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: layer.size,
          speed: layer.speed
        });
      }
    });
  }

  // Spawn star with balanced types
  function spawnStar() {
    const rand = Math.random();
    let type;
    if (rand < 0.4) type = "gold";
    else if (rand < 0.8) type = "blue";
    else type = "red";

    const size = 18;
    stars.push({
      x: randomRange(0, canvas.width - size),
      y: randomRange(0, canvas.height - size),
      size,
      type,
      vx: randomRange(-0.7, 0.7),
      vy: randomRange(-0.7, 0.7),
      baseGlow: 0
    });
  }

  // Spawn obstacle
  function spawnObstacle() {
    const size = 36;
    obstacles.push({
      x: randomRange(0, canvas.width - size),
      y: randomRange(0, canvas.height - size),
      size,
      vx: randomRange(-0.9, 0.9),
      vy: randomRange(-0.9, 0.9)
    });
  }

  // Audio beep on collect
  function playCollectSound(pitch = 1) {
    if (!audioContext || isMuted) return;
    const osc = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioContext.destination);
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(400 * pitch, audioContext.currentTime);
    gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
    osc.start();
    osc.stop(audioContext.currentTime + 0.1);
  }

  // Audio beep on obstacle hit (different)
  function playObstacleSound() {
    if (!audioContext || isMuted) return;
    const osc = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioContext.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(120, audioContext.currentTime);
    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
    osc.start();
    osc.stop(audioContext.currentTime + 0.2);
  }

  // Particle creation
  function createParticles(x, y, color, count=15) {
    for (let i=0; i<count; i++) {
      particles.push({
        x, y,
        dx: (Math.random() - 0.5) * 3,
        dy: (Math.random() - 0.5) * 3,
        life: 45,
        color,
        alpha: 1,
        decay: 0.025
      });
    }
  }

  // Update particles
  function updateParticles() {
    particles.forEach(p => {
      p.x += p.dx;
      p.y += p.dy;
      p.alpha -= p.decay;
      p.life--;
    });
    particles = particles.filter(p => p.life > 0 && p.alpha > 0);
  }

  // Update player trail
  function updatePlayerTrail() {
    player.trail.push({ x: player.x + player.size/2, y: player.y + player.size/2, alpha: 1 });
    if (player.trail.length > 20) player.trail.shift();
    player.trail.forEach(t => t.alpha -= 0.05);
    player.trail = player.trail.filter(t => t.alpha > 0);
  }

  // Draw player with trail and glow
  function drawPlayer() {
    player.trail.forEach(t => {
      const radius = player.size / 2;
      ctx.beginPath();
      ctx.fillStyle = `rgba(123, 228, 149, ${t.alpha})`;
      ctx.shadowColor = '#7be495';
      ctx.shadowBlur = 20 * t.alpha;
      ctx.arc(t.x, t.y, radius, 0, Math.PI * 2);
      ctx.fill();
    });

    ctx.fillStyle = colors.player;
    ctx.shadowColor = "#00ffcc";
    ctx.shadowBlur = 18;
    ctx.fillRect(player.x, player.y, player.size, player.size);
    ctx.shadowBlur = 0;
  }

  // Draw stars with glow
  function drawStars() {
    stars.forEach(star => {
      star.baseGlow += 0.05;
      const glow = (Math.sin(star.baseGlow) + 1) / 2;

      ctx.beginPath();
      ctx.fillStyle = colors[star.type];
      ctx.shadowColor = colors[star.type];
      ctx.shadowBlur = 12 + glow * 8;
      ctx.arc(star.x + star.size / 2, star.y + star.size / 2, star.size / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    });
  }

  // Draw obstacles with spikes
  function drawObstacleWithSpikes(obs) {
    const spikeCount = 8;
    const spikeLength = 9;
    const centerX = obs.x + obs.size / 2;
    const centerY = obs.y + obs.size / 2;

    ctx.fillStyle = colors.obstacle;
    ctx.shadowColor = "#ff0000";
    ctx.shadowBlur = 22;
    ctx.fillRect(obs.x, obs.y, obs.size, obs.size);
    ctx.shadowBlur = 0;

    ctx.fillStyle = colors.obstacle;
    ctx.beginPath();
    for (let i=0; i<spikeCount; i++) {
      const angle = (i / spikeCount) * Math.PI * 2;
      const x1 = centerX + Math.cos(angle) * (obs.size / 2);
      const y1 = centerY + Math.sin(angle) * (obs.size / 2);
      const x2 = centerX + Math.cos(angle) * (obs.size / 2 + spikeLength);
      const y2 = centerY + Math.sin(angle) * (obs.size / 2 + spikeLength);
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
    }
    ctx.lineWidth = 4;
    ctx.strokeStyle = colors.obstacle;
    ctx.stroke();
  }

  // Draw obstacles
  function drawObstacles() {
    obstacles.forEach(obs => {
      drawObstacleWithSpikes(obs);
    });
  }

  // Draw particles
  function drawParticles() {
    particles.forEach(p => {
      ctx.beginPath();
      ctx.fillStyle = `rgba(${hexToRgb(colors.player).join()},${p.alpha})`;
      ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // Hex to RGB helper
  function hexToRgb(hex) {
    const bigint = parseInt(hex.replace('#',''), 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
  }

  // Handle keyboard input
  window.addEventListener('keydown', e => {
    if (gameStarted && controlModeSelect.value === "pc") {
      const k = e.key.toLowerCase();
      if (["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"].includes(k)) {
        keys[k] = true;
        e.preventDefault();
      }
    }
  });
  window.addEventListener('keyup', e => {
    if (gameStarted && controlModeSelect.value === "pc") {
      const k = e.key.toLowerCase();
      if (["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"].includes(k)) {
        keys[k] = false;
        e.preventDefault();
      }
    }
  });

  // Handle joystick (mobile)
  let joystickTouchId = null;
  let joystickStart = { x: 0, y: 0 };

  joystickBase.style.display = "none";

  joystickBase.addEventListener('touchstart', e => {
    e.preventDefault();
    if (joystickTouchId === null) {
      joystickTouchId = e.changedTouches[0].identifier;
      joystickStart.x = e.changedTouches[0].clientX;
      joystickStart.y = e.changedTouches[0].clientY;
      joystickBase.style.left = (joystickStart.x - 50) + 'px';
      joystickBase.style.bottom = (window.innerHeight - joystickStart.y - 50) + 'px';
      joystickBase.style.display = 'block';
      joystickStick.style.transform = 'translate(0px, 0px)';
    }
  }, {passive:false});

  joystickBase.addEventListener('touchmove', e => {
    e.preventDefault();
    if (joystickTouchId !== null) {
      for (let touch of e.changedTouches) {
        if (touch.identifier === joystickTouchId) {
          let dx = touch.clientX - joystickStart.x;
          let dy = touch.clientY - joystickStart.y;
          let dist = Math.min(Math.hypot(dx, dy), 40);
          let angle = Math.atan2(dy, dx);
          dx = dist * Math.cos(angle);
          dy = dist * Math.sin(angle);
          joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
          // Set player velocity normalized for smooth control
          player.vx = (dx / 40) * player.speed;
          player.vy = (dy / 40) * player.speed;
        }
      }
    }
  }, {passive:false});

  joystickBase.addEventListener('touchend', e => {
    e.preventDefault();
    for (let touch of e.changedTouches) {
      if (touch.identifier === joystickTouchId) {
        joystickTouchId = null;
        joystickBase.style.display = 'none';
        joystickStick.style.transform = 'translate(0px, 0px)';
        player.vx = 0;
        player.vy = 0;
      }
    }
  }, {passive:false});

  // Handle PC keyboard controls
  function handleKeyboard() {
    player.vx = 0;
    player.vy = 0;
    if (keys['w'] || keys['arrowup']) player.vy = -player.speed;
    if (keys['s'] || keys['arrowdown']) player.vy = player.speed;
    if (keys['a'] || keys['arrowleft']) player.vx = -player.speed;
    if (keys['d'] || keys['arrowright']) player.vx = player.speed;
  }

  // Update game state
  function update() {
    if (!gameStarted) return;

    // Move player
    if (controlModeSelect.value === "pc") {
      handleKeyboard();
    }
    player.x += player.vx;
    player.y += player.vy;
    player.x = clamp(player.x, 0, canvas.width - player.size);
    player.y = clamp(player.y, 0, canvas.height - player.size);

    updatePlayerTrail();

    // Move stars
    stars.forEach(star => {
      star.x += star.vx;
      star.y += star.vy;
      // Bounce off walls
      if (star.x <= 0 || star.x + star.size >= canvas.width) star.vx *= -1;
      if (star.y <= 0 || star.y + star.size >= canvas.height) star.vy *= -1;
    });

    // Move obstacles
    obstacles.forEach(obs => {
      obs.x += obs.vx;
      obs.y += obs.vy;
      if (obs.x <= 0 || obs.x + obs.size >= canvas.width) obs.vx *= -1;
      if (obs.y <= 0 || obs.y + obs.size >= canvas.height) obs.vy *= -1;
    });

    // Check collisions with stars
    stars = stars.filter(star => {
      const collided = rectIntersect(player.x, player.y, player.size, player.size,
        star.x, star.y, star.size, star.size);
      if (collided) {
        if (star.type === "gold") {
          score += 1;
          playCollectSound(1.5);
          createParticles(star.x + star.size / 2, star.y + star.size / 2, colors.gold);
        } else if (star.type === "blue") {
          score += 2;
          playCollectSound(2);
          createParticles(star.x + star.size / 2, star.y + star.size / 2, colors.blue);
        } else if (star.type === "red") {
          score -= 1;
          playObstacleSound();
          createParticles(star.x + star.size / 2, star.y + star.size / 2, colors.red);
          if (score < 0) score = 0;
        }
        return false; // remove star
      }
      return true;
    });

    // Check collisions with obstacles
    obstacles.forEach(obs => {
      if (rectIntersect(player.x, player.y, player.size, player.size,
        obs.x, obs.y, obs.size, obs.size)) {
        score -= 1;
        playObstacleSound();
        createParticles(player.x + player.size / 2, player.y + player.size / 2, colors.red, 25);
        if (score < 0) score = 0;
        // Knockback player a bit
        player.x -= player.vx * 5;
        player.y -= player.vy * 5;
      }
    });

    updateParticles();

    // Spawn stars based on level and chance
    if (Math.random() < 0.4 + (level * 0.03)) spawnStar();

    // Spawn obstacles capped at 3 max and less frequent
    if (obstacles.length < 3 && Math.random() < 0.008) spawnObstacle();

    // Update HUD
    scoreDisplay.textContent = "Score: " + score;
    timeDisplay.textContent = "Time: " + timeLeft;
    levelDisplay.textContent = "Level: " + level;
  }

  // Draw everything
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw BG stars layers
    bgStarsLayers.forEach(layer => {
      layer.stars.forEach(star => {
        star.x -= layer.speed;
        if (star.x < 0) star.x = canvas.width;
        ctx.fillStyle = "white";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(star.x, star.y, layer.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    });

    drawStars();
    drawObstacles();
    drawPlayer();
    drawParticles();
  }

  // Game loop
  function gameLoop() {
    update();
    draw();
    if (gameStarted) requestAnimationFrame(gameLoop);
  }

  // Resize canvas
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    resetPlayer();
    initBgStars();
  }
  window.addEventListener('resize', resize);

  // Timer countdown
  let timerInterval = null;
  function startTimer() {
    timerInterval = setInterval(() => {
      timeLeft--;
      if (timeLeft <= 0) {
        timeLeft = 0;
        endGame();
      }
      timeDisplay.textContent = "Time: " + timeLeft;
    }, 1000);
  }
  function stopTimer() {
    if (timerInterval) clearInterval(timerInterval);
  }

  // Leaderboard data
  let leaderboard = [];

  function updateLeaderboard(name, score) {
    leaderboard.push({name, score});
    leaderboard.sort((a,b) => b.score - a.score);
    if (leaderboard.length > 5) leaderboard.pop();
    renderLeaderboard();
  }

  function renderLeaderboard() {
    leaderboardList.innerHTML = '';
    leaderboard.forEach(entry => {
      const li = document.createElement('li');
      li.textContent = `${entry.name}: ${entry.score}`;
      leaderboardList.appendChild(li);
    });
  }

  // Start game
  function startGame() {
    if (!playerNameInput.value.trim()) {
      alert("Please enter your name!");
      return;
    }
    setupAudio();
    score = 0;
    timeLeft = 30;
    level = 1;
    stars = [];
    obstacles = [];
    particles = [];
    keys = {};
    resetPlayer();
    updateLeaderboardDisplayVisibility(true);
    startOverlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    gameStarted = true;
    if (controlModeSelect.value === 'mobile') {
      joystickBase.style.display = 'block';
    } else {
      joystickBase.style.display = 'none';
    }
    startTimer();
    gameLoop();
  }

  // End game
  function endGame() {
    gameStarted = false;
    stopTimer();
    finalScoreDisplay.textContent = `${playerNameInput.value.trim()}, your score: ${score}`;
    updateLeaderboard(playerNameInput.value.trim(), score);
    gameOverOverlay.style.display = 'flex';
    joystickBase.style.display = 'none';
  }

  // Restart game
  function restartGame() {
    startOverlay.style.display = 'flex';
    gameOverOverlay.style.display = 'none';
  }

  function updateLeaderboardDisplayVisibility(show) {
    document.getElementById('leaderboard').style.display = show ? 'block' : 'none';
  }

  // Init
  resize();
  updateLeaderboardDisplayVisibility(true);

  // Event listeners
  startBtn.onclick = () => startGame();
  restartBtn.onclick = () => restartGame();

  // Keyboard Enter key starts game if on input
  playerNameInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      startGame();
    }
  });

  // Control mode change shows/hides joystick
  controlModeSelect.addEventListener('change', () => {
    if (controlModeSelect.value === 'mobile' && gameStarted) {
      joystickBase.style.display = 'block';
    } else {
      joystickBase.style.display = 'none';
    }
  });

})();
</script>

</body>
</html>
