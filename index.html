<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Catch the Star - Neon Space Edition - Kuzo</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: #0b1221;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    height: 100%;
    color: #7be495;
  }
  #gameCanvas {
    display: block;
    margin: 0 auto;
    background: transparent;
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 1;
  }
  #hud {
    position: fixed;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 25px;
    font-size: 22px;
    font-weight: 700;
    text-shadow: 0 0 6px #7be495cc;
    z-index: 20;
    user-select: none;
  }
  #muteBtn {
    position: fixed;
    top: 12px;
    right: 20px;
    background: #192934;
    border: none;
    color: #7be495;
    font-weight: bold;
    padding: 8px 12px;
    border-radius: 6px;
    cursor: pointer;
    text-shadow: 0 0 8px #7be495cc;
    z-index: 20;
    user-select: none;
    transition: background 0.3s;
  }
  #muteBtn:hover {
    background: #4caf50;
  }
  #bottomCreditRight {
    position: fixed;
    bottom: 8px;
    right: 12px;
    font-size: 14px;
    font-weight: 600;
    color: #7be495cc;
    user-select: none;
    z-index: 20;
    text-shadow: 0 0 8px #7be495cc;
  }
  #bottomCreditLeft {
    position: fixed;
    bottom: 8px;
    left: 12px;
    font-size: 14px;
    font-weight: 600;
    color: #7be495cc;
    user-select: none;
    z-index: 20;
    text-shadow: 0 0 8px #7be495cc;
  }
  #startOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(11, 18, 33, 0.9);
    color: #7be495;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 26px;
    font-weight: 700;
    user-select: none;
    z-index: 30;
  }
  #startBtn {
    margin-top: 20px;
    font-size: 22px;
    background: linear-gradient(45deg, #7be495, #4caf50);
    border: none;
    padding: 15px 40px;
    border-radius: 10px;
    color: #0b1221;
    cursor: pointer;
    box-shadow: 0 0 15px #4caf50aa;
    font-weight: 800;
    user-select: none;
    transition: background 0.3s;
  }
  #startBtn:hover {
    background: linear-gradient(45deg, #4caf50, #7be495);
  }
  #gameOverOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(11, 18, 33, 0.95);
    color: #7be495;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 28px;
    font-weight: 700;
    user-select: none;
    z-index: 35;
  }
  #restartBtn {
    margin-top: 25px;
    font-size: 24px;
    background: linear-gradient(45deg, #7be495, #4caf50);
    border: none;
    padding: 14px 44px;
    border-radius: 10px;
    color: #0b1221;
    cursor: pointer;
    box-shadow: 0 0 18px #4caf50cc;
    font-weight: 800;
    user-select: none;
    transition: background 0.3s;
  }
  #restartBtn:hover {
    background: linear-gradient(45deg, #4caf50, #7be495);
  }
  #leaderboard {
    position: fixed;
    top: 60px;
    right: 20px;
    width: 200px;
    background: rgba(11, 18, 33, 0.85);
    border-radius: 10px;
    padding: 10px 15px;
    color: #7be495cc;
    font-weight: 700;
    font-size: 16px;
    z-index: 25;
    user-select: none;
  }
  #leaderboard h3 {
    margin: 0 0 10px 0;
    color: #7be495;
    text-align: center;
  }
  #leaderboard ul {
    list-style: none;
    padding-left: 10px;
    margin: 0;
  }
  #leaderboard li {
    padding: 3px 0;
    border-bottom: 1px solid #7be49533;
  }
  #joystickBase {
    position: fixed;
    bottom: 50px;
    left: 50px;
    width: 100px;
    height: 100px;
    background: #192934cc;
    border-radius: 50%;
    display: none;
    touch-action: none;
    z-index: 40;
  }
  #joystickStick {
    position: absolute;
    top: 40px;
    left: 40px;
    width: 20px;
    height: 20px;
    background: #4caf50cc;
    border-radius: 50%;
    transform: translate(0, 0);
    transition: transform 0.1s;
  }
  #controlModeSelect {
    margin-top: 15px;
    font-size: 18px;
    padding: 6px 12px;
    border-radius: 8px;
    border: none;
    background: #0b1221cc;
    color: #7be495;
    cursor: pointer;
    user-select: none;
  }
  #playerNameInput {
    margin-top: 15px;
    padding: 8px 12px;
    border-radius: 8px;
    border: none;
    width: 200px;
    font-size: 18px;
    color: #7be495;
    background: #0b1221cc;
    text-align: center;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  <div id="score">Score: 0</div>
  <div id="time">Time: 30</div>
  <div id="level">Level: 1 Ã—1</div>
</div>

<button id="muteBtn" title="Toggle Mute">ðŸ”Š</button>

<div id="bottomCreditRight">by Anar &amp; Ermuun</div>
<div id="bottomCreditLeft">Credits to Tselmeg</div>

<div id="startOverlay">
  Catch the Star<br>
  <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="15" />
  <select id="controlModeSelect" title="Select Control Mode">
    <option value="pc" selected>PC (Keyboard)</option>
    <option value="mobile">Mobile (Joystick)</option>
  </select>
  <button id="startBtn">Start Game</button>
  <div id="leaderboard">
    <h3>Leaderboard</h3>
    <ul id="leaderboardList"></ul>
  </div>
</div>

<div id="gameOverOverlay">
  Game Over!<br>
  <div id="finalScore" style="margin-top:12px;"></div>
  <button id="restartBtn">Restart</button>
</div>

<div id="joystickBase">
  <div id="joystickStick"></div>
</div>

<script>
(() => {
  // DOM refs
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreDisplay = document.getElementById('score');
  const timeDisplay = document.getElementById('time');
  const levelDisplay = document.getElementById('level');
  const muteBtn = document.getElementById('muteBtn');
  const startOverlay = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreDisplay = document.getElementById('finalScore');
  const restartBtn = document.getElementById('restartBtn');
  const playerNameInput = document.getElementById('playerNameInput');
  const controlModeSelect = document.getElementById('controlModeSelect');
  const leaderboardList = document.getElementById('leaderboardList');
  const joystickBase = document.getElementById('joystickBase');
  const joystickStick = document.getElementById('joystickStick');

  // Audio
  let audioContext = null;
  let bgMusic = null;
  let isMuted = false;

  function setupAudio() {
    // create audioContext for sound effects
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (!bgMusic) {
      bgMusic = new Audio("https://cdn.jsdelivr.net/gh/jshawl/catch-the-star-assets/spacey-arcade-loop.mp3");
      bgMusic.loop = true;
      bgMusic.volume = 0.3;
      bgMusic.muted = isMuted;
      // attempt play - will succeed after user gesture (start button)
      const p = bgMusic.play();
      if (p && p.catch) p.catch(() => { /* autoplay may be blocked until gesture, OK */ });
    }
  }

  // Colors & player
  const colors = {
    gold: "#ffdd57",
    blue: "#57ddff",
    red: "#ff5757",
    player: "#7be495",
    obstacle: "#ff4444"
  };

  const player = { size: 28, x: 0, y: 0, speed: 5, vx: 0, vy: 0, trail: [] };

  // Game state
  let keys = {};
  let stars = [];
  let obstacles = [];
  let particles = [];
  const bgStarsLayers = [
    { count: 100, speed: 0.2, size: 1, stars: [] },
    { count: 60, speed: 0.4, size: 1.5, stars: [] },
    { count: 40, speed: 0.7, size: 2, stars: [] }
  ];

  let score = 0;
  let timeLeft = 30;
  let level = 1;
  let gameStarted = false;
  let timerInterval = null;

  // Multiplier system
  let multiplier = 1;
  let multiplierTimer = 0;
  const multiplierDuration = 3000; // ms

  // Screen shake
  let shakeTime = 0;
  let shakeIntensity = 0;
  function triggerShake(intensity, duration) {
    shakeIntensity = intensity;
    shakeTime = duration;
  }

  // Utils
  function randomRange(min, max) { return Math.random() * (max - min) + min; }
  function clamp(num, min, max) { return Math.min(Math.max(num, min), max); }
  function distance(x1,y1,x2,y2) { return Math.hypot(x2-x1, y2-y1); }
  function rectIntersect(x1,y1,w1,h1, x2,y2,w2,h2) {
    return !(x2 > x1 + w1 || x2 + w2 < x1 || y2 > y1 + h1 || y2 + h2 < y1);
  }
  function hexToRgb(hex) {
    const h = hex.replace('#','');
    const bigint = parseInt(h, 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
  }

  // Player helpers
  function resetPlayer() {
    player.x = canvas.width / 2 - player.size / 2;
    player.y = canvas.height / 2 - player.size / 2;
    player.vx = 0;
    player.vy = 0;
    player.trail = [];
  }

  function updatePlayerTrail() {
    player.trail.push({ x: player.x + player.size/2, y: player.y + player.size/2, alpha: 1 });
    if (player.trail.length > 20) player.trail.shift();
    player.trail.forEach(t => t.alpha -= 0.05);
    player.trail = player.trail.filter(t => t.alpha > 0);
  }

  // Particles
  function createParticles(x, y, color, count = 15) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x, y,
        dx: (Math.random() - 0.5) * 3,
        dy: (Math.random() - 0.5) * 3,
        life: 45,
        color,
        alpha: 1,
        decay: 0.025 + Math.random() * 0.02
      });
    }
  }
  function updateParticles() {
    particles.forEach(p => {
      p.x += p.dx;
      p.y += p.dy;
      p.alpha -= p.decay;
      p.life--;
    });
    particles = particles.filter(p => p.life > 0 && p.alpha > 0);
  }

  // Audio effects (oscillators) for collect/hit
  function playCollectSound(pitch = 1) {
    if (!audioContext || isMuted) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const osc = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioContext.destination);
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(400 * pitch, audioContext.currentTime);
    gainNode.gain.setValueAtTime(0.12, audioContext.currentTime);
    osc.start();
    osc.stop(audioContext.currentTime + 0.1);
  }
  function playObstacleSound() {
    if (!audioContext || isMuted) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    const osc = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioContext.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(120, audioContext.currentTime);
    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
    osc.start();
    osc.stop(audioContext.currentTime + 0.18);
  }

  // Spawn functions (balanced)
  function spawnStar() {
    const rand = Math.random();
    let type;
    if (rand < 0.5) type = "gold";
    else if (rand < 0.85) type = "blue";
    else type = "red";

    const size = 18;
    stars.push({
      x: randomRange(0, canvas.width - size),
      y: randomRange(0, canvas.height - size),
      size,
      type,
      vx: randomRange(-0.6, 0.6),
      vy: randomRange(-0.6, 0.6),
      baseGlow: randomRange(0, Math.PI * 2)
    });
  }

  function spawnObstacle() {
    const size = 36;
    obstacles.push({
      x: randomRange(0, canvas.width - size),
      y: randomRange(0, canvas.height - size),
      size,
      vx: randomRange(-0.8, 0.8),
      vy: randomRange(-0.8, 0.8)
    });
  }

  // Drawing helpers
  function drawPlayer() {
    // trail
    const prgb = hexToRgb(colors.player);
    player.trail.forEach(t => {
      const radius = player.size / 2;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(' + prgb.join(',') + ',' + t.alpha + ')';
      ctx.shadowColor = colors.player;
      ctx.shadowBlur = 20 * t.alpha;
      ctx.arc(t.x, t.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    });

    // player body
    ctx.fillStyle = colors.player;
    ctx.shadowColor = "#00ffcc";
    // increase glow when multiplier active
    const glowFactor = 18 * (1 + Math.min(multiplier - 1, 6) * 0.12);
    ctx.shadowBlur = glowFactor;
    ctx.fillRect(player.x, player.y, player.size, player.size);
    ctx.shadowBlur = 0;
  }

  function drawStars() {
    stars.forEach(star => {
      star.baseGlow += 0.06;
      const glow = (Math.sin(star.baseGlow) + 1) / 2;
      ctx.beginPath();
      ctx.fillStyle = colors[star.type];
      ctx.shadowColor = colors[star.type];
      ctx.shadowBlur = 12 + glow * 8;
      ctx.arc(star.x + star.size / 2, star.y + star.size / 2, star.size / 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    });
  }

  function drawObstacleWithSpikes(obs) {
    const spikeCount = 8;
    const spikeLength = 9;
    const centerX = obs.x + obs.size / 2;
    const centerY = obs.y + obs.size / 2;

    ctx.fillStyle = colors.obstacle;
    ctx.shadowColor = "#ff0000";
    ctx.shadowBlur = 22;
    ctx.fillRect(obs.x, obs.y, obs.size, obs.size);
    ctx.shadowBlur = 0;

    ctx.beginPath();
    for (let i = 0; i < spikeCount; i++) {
      const angle = (i / spikeCount) * Math.PI * 2;
      const x1 = centerX + Math.cos(angle) * (obs.size / 2);
      const y1 = centerY + Math.sin(angle) * (obs.size / 2);
      const x2 = centerX + Math.cos(angle) * (obs.size / 2 + spikeLength);
      const y2 = centerY + Math.sin(angle) * (obs.size / 2 + spikeLength);
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
    }
    ctx.lineWidth = 4;
    ctx.strokeStyle = colors.obstacle;
    ctx.stroke();
  }

  function drawObstacles() {
    obstacles.forEach(obs => drawObstacleWithSpikes(obs));
  }

  function drawParticles() {
    particles.forEach(p => {
      ctx.beginPath();
      const rgb = hexToRgb(p.color);
      ctx.fillStyle = 'rgba(' + rgb.join(',') + ',' + p.alpha + ')';
      ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // Input handlers
  window.addEventListener('keydown', e => {
    if (gameStarted && controlModeSelect.value === "pc") {
      const k = e.key.toLowerCase();
      if (["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"].includes(k)) {
        keys[k] = true;
        e.preventDefault();
      }
    }
  });
  window.addEventListener('keyup', e => {
    if (gameStarted && controlModeSelect.value === "pc") {
      const k = e.key.toLowerCase();
      if (["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"].includes(k)) {
        keys[k] = false;
        e.preventDefault();
      }
    }
  });

  function handleKeyboard() {
    player.vx = 0;
    player.vy = 0;
    if (keys['w'] || keys['arrowup']) player.vy = -player.speed;
    if (keys['s'] || keys['arrowdown']) player.vy = player.speed;
    if (keys['a'] || keys['arrowleft']) player.vx = -player.speed;
    if (keys['d'] || keys['arrowright']) player.vx = player.speed;
  }

  // Joystick (mobile)
  let joystickTouchId = null;
  let joystickStart = { x: 0, y: 0 };

  joystickBase.style.display = "none";

  joystickBase.addEventListener('touchstart', e => {
    e.preventDefault();
    if (joystickTouchId === null) {
      const t = e.changedTouches[0];
      joystickTouchId = t.identifier;
      joystickStart.x = t.clientX;
      joystickStart.y = t.clientY;
      // position base where touched
      joystickBase.style.left = (joystickStart.x - 50) + 'px';
      joystickBase.style.bottom = (window.innerHeight - joystickStart.y - 50) + 'px';
      joystickBase.style.display = 'block';
      joystickStick.style.transform = 'translate(0px, 0px)';
    }
  }, {passive:false});

  joystickBase.addEventListener('touchmove', e => {
    e.preventDefault();
    if (joystickTouchId !== null) {
      for (let touch of e.changedTouches) {
        if (touch.identifier === joystickTouchId) {
          let dx = touch.clientX - joystickStart.x;
          let dy = touch.clientY - joystickStart.y;
          let dist = Math.min(Math.hypot(dx, dy), 40);
          let angle = Math.atan2(dy, dx);
          dx = dist * Math.cos(angle);
          dy = dist * Math.sin(angle);
          joystickStick.style.transform = 'translate(' + dx + 'px, ' + dy + 'px)';
          player.vx = (dx / 40) * player.speed;
          player.vy = (dy / 40) * player.speed;
        }
      }
    }
  }, {passive:false});

  joystickBase.addEventListener('touchend', e => {
    e.preventDefault();
    for (let touch of e.changedTouches) {
      if (touch.identifier === joystickTouchId) {
        joystickTouchId = null;
        joystickBase.style.display = 'none';
        joystickStick.style.transform = 'translate(0px, 0px)';
        player.vx = 0;
        player.vy = 0;
      }
    }
  }, {passive:false});

  // Game update loop
  function update() {
    if (!gameStarted) return;

    // Player movement
    if (controlModeSelect.value === "pc") handleKeyboard();
    player.x += player.vx;
    player.y += player.vy;
    player.x = clamp(player.x, 0, canvas.width - player.size);
    player.y = clamp(player.y, 0, canvas.height - player.size);

    updatePlayerTrail();

    // Move stars
    stars.forEach(star => {
      star.x += star.vx;
      star.y += star.vy;
      if (star.x <= 0 || star.x + star.size >= canvas.width) star.vx *= -1;
      if (star.y <= 0 || star.y + star.size >= canvas.height) star.vy *= -1;
    });

    // Move obstacles
    obstacles.forEach(obs => {
      obs.x += obs.vx;
      obs.y += obs.vy;
      if (obs.x <= 0 || obs.x + obs.size >= canvas.width) obs.vx *= -1;
      if (obs.y <= 0 || obs.y + obs.size >= canvas.height) obs.vy *= -1;
    });

    // Check collisions with stars (apply multiplier)
    stars = stars.filter(star => {
      const collided = rectIntersect(player.x, player.y, player.size, player.size,
        star.x, star.y, star.size, star.size);
      if (collided) {
        if (star.type === "gold") {
          score += 1 * multiplier;
          multiplier += 1; // gold increases multiplier by 1
          multiplierTimer = Date.now();
          playCollectSound(1.5);
          createParticles(star.x + star.size / 2, star.y + star.size / 2, colors.gold);
        } else if (star.type === "blue") {
          score += 2 * multiplier;
          multiplier += 2; // blue gives a bigger multiplier bump
          multiplierTimer = Date.now();
          playCollectSound(2);
          createParticles(star.x + star.size / 2, star.y + star.size / 2, colors.blue);
        } else if (star.type === "red") {
          // penalty scales with current multiplier
          score = Math.max(0, score - (1 * multiplier));
          multiplier = 1;
          playObstacleSound();
          triggerShake(10, 18);
          createParticles(star.x + star.size / 2, star.y + star.size / 2, colors.red);
        }
        return false;
      }
      return true;
    });

    // Check collisions with obstacles
    obstacles.forEach(obs => {
      if (rectIntersect(player.x, player.y, player.size, player.size,
        obs.x, obs.y, obs.size, obs.size)) {
        score = Math.max(0, score - (1 * multiplier)); // penalty scales with multiplier
        multiplier = 1;
        playObstacleSound();
        triggerShake(12, 20);
        createParticles(player.x + player.size / 2, player.y + player.size / 2, colors.red, 25);
        // Knockback
        player.x -= player.vx * 5;
        player.y -= player.vy * 5;
      }
    });

    // Multiplier timeout
    if (multiplier > 1 && Date.now() - multiplierTimer > multiplierDuration) {
      multiplier = 1;
    }

    updateParticles();

    // Balanced spawn rates
    if (stars.length < 8 && Math.random() < 0.15 + (level * 0.015)) spawnStar();
    if (obstacles.length < 2 + Math.floor(level / 3) && Math.random() < 0.004 + level * 0.0005) {
      spawnObstacle();
    }

    // HUD update
    scoreDisplay.textContent = "Score: " + score;
    timeDisplay.textContent = "Time: " + timeLeft;
    levelDisplay.textContent = "Level: " + level + " Ã—" + multiplier;
  }

  // Drawing everything (with shake)
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    if (shakeTime > 0) {
      const dx = (Math.random() - 0.5) * shakeIntensity;
      const dy = (Math.random() - 0.5) * shakeIntensity;
      ctx.translate(dx, dy);
      shakeTime--;
    }

    // Background layers
    bgStarsLayers.forEach(layer => {
      layer.stars.forEach(st => {
        st.x -= layer.speed;
        if (st.x < -10) st.x = canvas.width + 10;
        ctx.fillStyle = "white";
        ctx.shadowColor = "white";
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(st.x, st.y, layer.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      });
    });

    drawStars();
    drawObstacles();
    drawPlayer();
    drawParticles();

    ctx.restore();
  }

  // Game loop
  function gameLoop() {
    update();
    draw();
    if (gameStarted) requestAnimationFrame(gameLoop);
  }

  // Resize & init background stars
  function initBgStars() {
    bgStarsLayers.forEach(layer => {
      layer.stars = [];
      for (let i = 0; i < layer.count; i++) {
        layer.stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: layer.size,
          speed: layer.speed
        });
      }
    });
  }

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    resetPlayer();
    initBgStars();
  }
  window.addEventListener('resize', resize);

  // Timer
  function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      timeLeft--;
      if (timeLeft <= 0) {
        timeLeft = 0;
        endGame();
      }
      timeDisplay.textContent = "Time: " + timeLeft;
    }, 1000);
  }
  function stopTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
  }

  // Leaderboard (in-memory)
  let leaderboard = [];
  function updateLeaderboard(name, sc) {
    if (!name) name = "Player";
    leaderboard.push({name, score: sc});
    leaderboard.sort((a,b) => b.score - a.score);
    if (leaderboard.length > 5) leaderboard = leaderboard.slice(0,5);
    renderLeaderboard();
  }
  function renderLeaderboard() {
    leaderboardList.innerHTML = '';
    leaderboard.forEach(entry => {
      const li = document.createElement('li');
      li.textContent = entry.name + ': ' + entry.score;
      leaderboardList.appendChild(li);
    });
  }
  function updateLeaderboardDisplayVisibility(show) {
    document.getElementById('leaderboard').style.display = show ? 'block' : 'none';
  }

  // Start game
  function startGame() {
    if (!playerNameInput.value.trim()) {
      alert("Please enter your name!");
      return;
    }
    setupAudio();
    score = 0;
    timeLeft = 30;
    level = 1;
    stars = [];
    obstacles = [];
    particles = [];
    keys = {};
    multiplier = 1;
    multiplierTimer = 0;
    resetPlayer();
    updateLeaderboardDisplayVisibility(true);
    startOverlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    gameStarted = true;
    if (controlModeSelect.value === 'mobile') {
      joystickBase.style.display = 'block';
    } else {
      joystickBase.style.display = 'none';
    }
    startTimer();
    gameLoop();
  }

  // End game
  function endGame() {
    gameStarted = false;
    stopTimer();
    finalScoreDisplay.textContent = playerNameInput.value.trim() + ', your score: ' + score;
    updateLeaderboard(playerNameInput.value.trim(), score);
    gameOverOverlay.style.display = 'flex';
    joystickBase.style.display = 'none';
  }

  // Restart -> bring back start overlay
  function restartGame() {
    startOverlay.style.display = 'flex';
    gameOverOverlay.style.display = 'none';
  }

  // Event listeners wiring
  startBtn.onclick = startGame;
  restartBtn.onclick = restartGame;

  playerNameInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') startGame();
  });

  controlModeSelect.addEventListener('change', () => {
    if (controlModeSelect.value === 'mobile' && gameStarted) {
      joystickBase.style.display = 'block';
    } else {
      joystickBase.style.display = 'none';
    }
  });

  muteBtn.onclick = () => {
    isMuted = !isMuted;
    if (bgMusic) bgMusic.muted = isMuted;
    muteBtn.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
  };

  // Initial layout
  resize();
  updateLeaderboardDisplayVisibility(true);
  renderLeaderboard();

})();
</script>

</body>
</html>
