<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Catch the Star - Fixed Final</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: #0b1221;
    font-family: Arial, sans-serif;
    color: #7be495;
    user-select: none;
    height: 100%;
  }
  canvas {
    display: block;
    position: absolute;
    top:0; left:0;
  }
  #hud {
    position: fixed;
    top: 10px; left: 50%;
    transform: translateX(-50%);
    color: #7be495;
    font-weight: bold;
    font-size: 22px;
    text-shadow: 0 0 5px #7be495bb;
    user-select: none;
    display: flex;
    gap: 30px;
    z-index: 10;
  }
  #startOverlay, #gameOverOverlay {
    position: fixed;
    top: 0; left: 0; right:0; bottom: 0;
    background: rgba(11, 18, 33, 0.95);
    color: #7be495;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-weight: 700;
    font-size: 28px;
    user-select: none;
    z-index: 20;
  }
  #startOverlay > * {
    margin: 10px 0;
  }
  input, select {
    font-size: 20px;
    padding: 6px 10px;
    border-radius: 6px;
    border: none;
    text-align: center;
    color: #0b1221;
    font-weight: 600;
  }
  button {
    font-size: 22px;
    padding: 12px 36px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    background: linear-gradient(45deg, #7be495, #4caf50);
    color: #0b1221;
    font-weight: 800;
    box-shadow: 0 0 15px #4caf50cc;
  }
  button:disabled {
    background: #466e44;
    cursor: not-allowed;
  }
  #joystickContainer {
    position: fixed;
    bottom: 30px;
    left: 30px;
    width: 120px;
    height: 120px;
    background: rgba(123, 228, 149, 0.15);
    border-radius: 50%;
    touch-action: none;
    display: none;
    z-index: 15;
  }
  #joystickBase {
    position: absolute;
    width: 100%;
    height: 100%;
    border: 2px solid #7be495;
    border-radius: 50%;
  }
  #joystickThumb {
    position: absolute;
    width: 50px;
    height: 50px;
    background: #7be495;
    border-radius: 50%;
    top: 35px;
    left: 35px;
    box-shadow: 0 0 15px #7be495bb;
    transition: top 0.05s, left 0.05s;
  }
  #leaderboard ol {
    margin: 0;
    padding-left: 20px;
    font-weight: 600;
    font-size: 20px;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  <div id="score">Score: 0</div>
  <div id="time">Time: 30</div>
  <div id="level">Level: 1</div>
  <div id="combo">Combo: x1</div>
</div>

<div id="startOverlay">
  <div>Catch the Star</div>
  <input type="text" id="playerName" placeholder="Enter your name" maxlength="15" />
  <select id="controlType">
    <option value="pc">PC (Keyboard)</option>
    <option value="mobile">Mobile (Joystick)</option>
  </select>
  <button id="startBtn" disabled>Start Game</button>
</div>

<div id="gameOverOverlay" style="display:none;">
  <div>Game Over!</div>
  <div id="finalScore"></div>
  <div id="leaderboard">
    <h3>Leaderboard</h3>
    <ol id="leaderboardList"></ol>
  </div>
  <button id="restartBtn">Restart</button>
</div>

<div id="joystickContainer">
  <div id="joystickBase"></div>
  <div id="joystickThumb"></div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const scoreDisplay = document.getElementById('score');
  const timeDisplay = document.getElementById('time');
  const levelDisplay = document.getElementById('level');
  const comboDisplay = document.getElementById('combo');

  const startOverlay = document.getElementById('startOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreDisplay = document.getElementById('finalScore');
  const leaderboardList = document.getElementById('leaderboardList');

  const playerNameInput = document.getElementById('playerName');
  const controlTypeSelect = document.getElementById('controlType');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');

  const joystickContainer = document.getElementById('joystickContainer');
  const joystickThumb = document.getElementById('joystickThumb');

  // Canvas sizing
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // Player object
  const player = {
    x: 0,
    y: 0,
    size: 28,
    speed: 5,
    vx: 0,
    vy: 0,
    trail: [],
  };

  // Stars and obstacles
  const stars = [];
  const obstacles = [];
  let particles = [];

  // Background stars (for effect)
  const bgStars = [];
  const BG_STAR_COUNT = 100;

  // Game state
  let score = 0;
  let timeLeft = 30;
  let level = 1;
  let combo = 1;
  let comboTimer = 0;
  const comboResetTime = 1800;

  let gameStarted = false;

  // Control mode: 'pc' or 'mobile'
  let controlMode = 'pc';

  // Keyboard input
  const keys = {};

  // Joystick state
  const joystickState = {
    active: false,
    originX: 0,
    originY: 0,
    deltaX: 0,
    deltaY: 0,
    maxDistance: 40,
  };

  // Enable start button only if player name entered
  playerNameInput.addEventListener('input', () => {
    startBtn.disabled = playerNameInput.value.trim().length === 0;
  });

  // Show/hide joystick container based on control selection
  controlTypeSelect.addEventListener('change', () => {
    controlMode = controlTypeSelect.value;
    joystickContainer.style.display = controlMode === 'mobile' ? 'block' : 'none';
  });

  function randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }
  function clamp(num, min, max) {
    return Math.min(Math.max(num, min), max);
  }
  function dist(x1, y1, x2, y2) {
    return Math.hypot(x2 - x1, y2 - y1);
  }

  // Reset player position center screen
  function resetPlayer() {
    player.x = canvas.width / 2 - player.size / 2;
    player.y = canvas.height / 2 - player.size / 2;
    player.vx = 0;
    player.vy = 0;
    player.trail = [];
  }

  // Spawn background stars for effect
  function spawnBgStars() {
    bgStars.length = 0;
    for(let i=0; i<BG_STAR_COUNT; i++) {
      bgStars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 2 + 0.5,
        speed: Math.random() * 0.5 + 0.1
      });
    }
  }

  // Spawn a star with random type and position
  function spawnStar() {
    const types = ['gold', 'blue', 'red'];
    const type = types[Math.floor(Math.random() * types.length)];
    stars.push({
      x: randomRange(0, canvas.width - 18),
      y: randomRange(0, canvas.height - 18),
      size: 18,
      type,
      vx: randomRange(-0.3, 0.3),
      vy: randomRange(-0.3, 0.3),
      glow: 0,
    });
  }

  // Spawn an obstacle
  function spawnObstacle() {
    obstacles.push({
      x: randomRange(0, canvas.width - 36),
      y: randomRange(0, canvas.height - 36),
      size: 36,
      vx: randomRange(-0.6, 0.6),
      vy: randomRange(-0.6, 0.6)
    });
  }

  // Draw functions
  function drawBgStars() {
    ctx.fillStyle = "#5588cc88";
    bgStars.forEach(s => {
      ctx.beginPath();
      ctx.shadowColor = "#5588ccaa";
      ctx.shadowBlur = 6;
      ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    });
  }

  function drawPlayer() {
    // Trail
    player.trail.forEach(t => {
      ctx.beginPath();
      ctx.fillStyle = `rgba(123, 228, 149, ${t.alpha})`;
      ctx.shadowColor = "#7be495";
      ctx.shadowBlur = 20 * t.alpha;
      ctx.arc(t.x, t.y, player.size/2, 0, Math.PI*2);
      ctx.fill();
    });
    // Player rect
    ctx.fillStyle = "#7be495";
    ctx.shadowColor = "#00ffcc";
    ctx.shadowBlur = 15;
    ctx.fillRect(player.x, player.y, player.size, player.size);
    ctx.shadowBlur = 0;
  }

  function drawStars() {
    stars.forEach(star => {
      star.glow += 0.07;
      const glow = (Math.sin(star.glow) + 1) / 2;

      ctx.beginPath();
      let col;
      if(star.type === 'gold') col = "#ffdd57";
      else if(star.type === 'blue') col = "#57ddff";
      else col = "#ff5757";

      ctx.fillStyle = col;
      ctx.shadowColor = col;
      ctx.shadowBlur = 15 + glow * 10;
      ctx.arc(star.x + star.size/2, star.y + star.size/2, star.size/2, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    });
  }

  function drawObstacle(obs) {
    const spikeCount = 8;
    const spikeLength = 8;
    const cx = obs.x + obs.size/2;
    const cy = obs.y + obs.size/2;

    ctx.fillStyle = "#ff4444";
    ctx.shadowColor = "#ff0000";
    ctx.shadowBlur = 20;
    ctx.fillRect(obs.x, obs.y, obs.size, obs.size);
    ctx.shadowBlur = 0;

    ctx.fillStyle = "#ff0000";
    ctx.strokeStyle = "#aa0000";
    ctx.lineWidth = 2;
    for(let i=0; i<spikeCount; i++) {
      const angle = (Math.PI*2 / spikeCount) * i;
      const startX = cx + Math.cos(angle) * (obs.size/2);
      const startY = cy + Math.sin(angle) * (obs.size/2);
      const endX = cx + Math.cos(angle) * (obs.size/2 + spikeLength);
      const endY = cy + Math.sin(angle) * (obs.size/2 + spikeLength);

      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.lineTo(
        cx + Math.cos(angle + 0.1) * (obs.size/2 + spikeLength/2),
        cy + Math.sin(angle + 0.1) * (obs.size/2 + spikeLength/2)
      );
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }
  }

  function drawParticles() {
    particles.forEach(p => {
      ctx.beginPath();
      ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${p.alpha})`;
      ctx.shadowColor = `rgba(${p.r},${p.g},${p.b},${p.alpha})`;
      ctx.shadowBlur = 10;
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    });
  }

  // Particle creation helper
  function createParticles(x, y, color, count=15) {
    let r=0,g=0,b=0;
    if(color === 'gold') { r=255; g=221; b=87; }
    else if(color === 'blue') { r=87; g=221; b=255; }
    else if(color === 'red') { r=255; g=87; b=87; }
    else if(color === 'obstacle') { r=255; g=68; b=68; }
    for(let i=0; i<count; i++) {
      particles.push({
        x,
        y,
        size: Math.random()*3 + 2,
        r, g, b,
        dx: (Math.random()-0.5)*3,
        dy: (Math.random()-0.5)*3,
        alpha: 1,
        decay: 0.03 + Math.random()*0.02
      });
    }
  }

  // Update functions
  function updateParticles() {
    particles.forEach(p => {
      p.x += p.dx;
      p.y += p.dy;
      p.alpha -= p.decay;
    });
    particles = particles.filter(p => p.alpha > 0);
  }

  function updatePlayerTrail() {
    player.trail.push({ x: player.x + player.size/2, y: player.y + player.size/2, alpha: 1 });
    if(player.trail.length > 20) player.trail.shift();
    player.trail.forEach(t => t.alpha -= 0.05);
    player.trail = player.trail.filter(t => t.alpha > 0);
  }

  function update(delta) {
    // Update velocity based on control mode and input
    let targetVx = 0;
    let targetVy = 0;

    if(controlMode === 'pc') {
      if(keys['ArrowUp'] || keys['w'] || keys['W']) targetVy = -player.speed;
      if(keys['ArrowDown'] || keys['s'] || keys['S']) targetVy = player.speed;
      if(keys['ArrowLeft'] || keys['a'] || keys['A']) targetVx = -player.speed;
      if(keys['ArrowRight'] || keys['d'] || keys['D']) targetVx = player.speed;
    } else if(controlMode === 'mobile') {
      const normX = joystickState.deltaX / joystickState.maxDistance;
      const normY = joystickState.deltaY / joystickState.maxDistance;
      targetVx = normX * player.speed;
      targetVy = normY * player.speed;
    }

    // Smooth velocity changes
    player.vx += (targetVx - player.vx) * 0.3;
    player.vy += (targetVy - player.vy) * 0.3;

    player.x += player.vx;
    player.y += player.vy;

    player.x = clamp(player.x, 0, canvas.width - player.size);
    player.y = clamp(player.y, 0, canvas.height - player.size);

    // Move background stars slowly downward
    bgStars.forEach(s => {
      s.y += s.speed;
      if(s.y > canvas.height) s.y = 0;
    });

    // Move stars drifting slowly
    stars.forEach(star => {
      star.x += star.vx;
      star.y += star.vy;
      if(star.x < 0) star.x = canvas.width - star.size;
      else if(star.x > canvas.width - star.size) star.x = 0;
      if(star.y < 0) star.y = canvas.height - star.size;
      else if(star.y > canvas.height - star.size) star.y = 0;
    });

    // Move obstacles and bounce off edges
    obstacles.forEach(obs => {
      obs.x += obs.vx;
      obs.y += obs.vy;
      if(obs.x < 0 || obs.x > canvas.width - obs.size) obs.vx *= -1;
      if(obs.y < 0 || obs.y > canvas.height - obs.size) obs.vy *= -1;
    });

    // Check collision with stars
    stars.forEach((star, idx) => {
      const d = dist(player.x + player.size/2, player.y + player.size/2,
                     star.x + star.size/2, star.y + star.size/2);
      if(d < (player.size + star.size)/2) {
        if(star.type === 'gold') {
          score += 1;
          createParticles(star.x + star.size/2, star.y + star.size/2, 'gold');
        } else if(star.type === 'blue') {
          score += 2;
          timeLeft = Math.min(timeLeft + 2, 30);
          createParticles(star.x + star.size/2, star.y + star.size/2, 'blue');
        } else if(star.type === 'red') {
          score = Math.max(score - 1, 0);
          createParticles(star.x + star.size/2, star.y + star.size/2, 'red');
        }
        stars.splice(idx, 1);
        spawnStar();
        combo++;
        comboTimer = 0;
      }
    });

    // Check collision with obstacles
    obstacles.forEach(obs => {
      const d = dist(player.x + player.size/2, player.y + player.size/2,
                     obs.x + obs.size/2, obs.y + obs.size/2);
      if(d < (player.size + obs.size)/2) {
        score = Math.max(score - 3, 0);
        createParticles(obs.x + obs.size/2, obs.y + obs.size/2, 'obstacle', 30);
        combo = 1; // reset combo on obstacle hit
      }
    });

    comboTimer += delta;
    if(comboTimer > comboResetTime) {
      combo = 1;
      comboTimer = 0;
    }

    updateParticles();
    updatePlayerTrail();

    scoreDisplay.textContent = `Score: ${score}`;
    timeDisplay.textContent = `Time: ${Math.ceil(timeLeft)}`;
    levelDisplay.textContent = `Level: ${level}`;
    comboDisplay.textContent = `Combo: x${combo}`;

    if(gameStarted) {
      timeLeft -= delta/1000;
      if(timeLeft <= 0) {
        timeLeft = 0;
        endGame();
      }
    }
  }

  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBgStars();
    drawStars();
    obstacles.forEach(drawObstacle);
    drawPlayer();
    drawParticles();
  }

  // Joystick handlers
  function onJoystickStart(e) {
    e.preventDefault();
    joystickState.active = true;
    const touch = e.touches ? e.touches[0] : e;
    joystickState.originX = touch.clientX;
    joystickState.originY = touch.clientY;
    joystickState.deltaX = 0;
    joystickState.deltaY = 0;
    moveJoystickThumb(0,0);
  }
  function onJoystickMove(e) {
    if(!joystickState.active) return;
    e.preventDefault();
    const touch = e.touches ? e.touches[0] : e;
    let dx = touch.clientX - joystickState.originX;
    let dy = touch.clientY - joystickState.originY;

    const distFromOrigin = Math.hypot(dx, dy);
    if(distFromOrigin > joystickState.maxDistance) {
      const angle = Math.atan2(dy, dx);
      dx = Math.cos(angle)*joystickState.maxDistance;
      dy = Math.sin(angle)*joystickState.maxDistance;
    }
    joystickState.deltaX = dx;
    joystickState.deltaY = dy;
    moveJoystickThumb(dx, dy);
  }
  function onJoystickEnd(e) {
    e.preventDefault();
    joystickState.active = false;
    joystickState.deltaX = 0;
    joystickState.deltaY = 0;
    moveJoystickThumb(0,0);
  }
  function moveJoystickThumb(dx, dy) {
    joystickThumb.style.left = `${35 + dx}px`;
    joystickThumb.style.top = `${35 + dy}px`;
  }

  // Leaderboard (localStorage)
  const LEADERBOARD_KEY = "catchthestargame_leaderboard";

  function getLeaderboard() {
    const data = localStorage.getItem(LEADERBOARD_KEY);
    return data ? JSON.parse(data) : [];
  }
  function saveScoreToLeaderboard(name, score) {
    const lb = getLeaderboard();
    lb.push({name, score});
    lb.sort((a,b) => b.score - a.score);
    if(lb.length > 5) lb.length = 5;
    localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(lb));
  }
  function renderLeaderboard() {
    leaderboardList.innerHTML = '';
    const lb = getLeaderboard();
    if(lb.length === 0) {
      leaderboardList.innerHTML = '<li>No scores yet</li>';
      return;
    }
    lb.forEach(({name, score}) => {
      const li = document.createElement('li');
      li.textContent = `${name}: ${score}`;
      leaderboardList.appendChild(li);
    });
  }

  function endGame() {
    gameStarted = false;
    gameOverOverlay.style.display = 'flex';
    finalScoreDisplay.textContent = `Your Score: ${score}`;

    const playerName = playerNameInput.value.trim() || "Unknown";
    saveScoreToLeaderboard(playerName, score);
    renderLeaderboard();

    joystickContainer.style.display = 'none';
  }

  function startGame() {
    startOverlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    score = 0;
    timeLeft = 30;
    level = 1;
    combo = 1;
    comboTimer = 0;
    stars.length = 0;
    obstacles.length = 0;
    particles.length = 0;
    spawnBgStars();
    for(let i=0; i<12; i++) spawnStar();
    for(let i=0; i<5; i++) spawnObstacle();
    resetPlayer();
    gameStarted = true;

    joystickContainer.style.display = controlMode === 'mobile' ? 'block' : 'none';
  }

  startBtn.onclick = () => {
    if(playerNameInput.value.trim().length === 0) return;
    controlMode = controlTypeSelect.value;
    startGame();
  };

  restartBtn.onclick = () => {
    controlMode = controlTypeSelect.value;
    startGame();
  };

  // Keyboard listeners
  window.addEventListener('keydown', e => keys[e.key] = true);
  window.addEventListener('keyup', e => keys[e.key] = false);

  // Joystick listeners
  joystickContainer.addEventListener('touchstart', onJoystickStart, {passive:false});
  joystickContainer.addEventListener('touchmove', onJoystickMove, {passive:false});
  joystickContainer.addEventListener('touchend', onJoystickEnd, {passive:false});
  joystickContainer.addEventListener('touchcancel', onJoystickEnd, {passive:false});
  joystickContainer.addEventListener('mousedown', onJoystickStart);
  window.addEventListener('mousemove', onJoystickMove);
  window.addEventListener('mouseup', onJoystickEnd);

  // Main loop
  let lastTime = 0;
  function gameLoop(timestamp = 0) {
    const delta = timestamp - lastTime;
    lastTime = timestamp;

    if(gameStarted) {
      update(delta);
      draw();
    }
    requestAnimationFrame(gameLoop);
  }
  gameLoop();

})();
</script>

</body>
</html>
